diff -I "NOTICE" -I "DETAIL" -I "WARNING" -U3 /Users/voffk4/work/old_repos/orioledb/test/expected/ddl.out /Users/voffk4/work/old_repos/orioledb/test/results/ddl.out
--- /Users/voffk4/work/old_repos/orioledb/test/expected/ddl.out	2026-01-15 18:41:44
+++ /Users/voffk4/work/old_repos/orioledb/test/results/ddl.out	2026-01-21 18:06:01
@@ -1519,6 +1519,906 @@
 CREATE TABLE test_set_access_method_fail (i int PRIMARY KEY, t text) USING orioledb;
 ALTER TABLE test_set_access_method_fail SET ACCESS METHOD heap;
 ERROR:  changing access method is not supported for OrioleDB tables
+-- Test AT_SetStatistics
+CREATE TABLE test_set_statistics (
+	i int PRIMARY KEY,
+	t text,
+	v varchar
+) USING orioledb;
+INSERT INTO test_set_statistics VALUES (1, 'test', 'data');
+-- Set statistics target for columns
+ALTER TABLE test_set_statistics ALTER COLUMN t SET STATISTICS 100;
+ALTER TABLE test_set_statistics ALTER COLUMN v SET STATISTICS 1000;
+-- Verify the changes
+SELECT attname, attstattarget
+FROM pg_attribute
+WHERE attrelid = 'test_set_statistics'::regclass
+  AND attnum > 0
+ORDER BY attnum;
+ attname | attstattarget 
+---------+---------------
+ i       |              
+ t       |           100
+ v       |          1000
+(3 rows)
+
+-- Reset statistics to default
+ALTER TABLE test_set_statistics ALTER COLUMN t SET STATISTICS DEFAULT;
+SELECT attname, attstattarget
+FROM pg_attribute
+WHERE attrelid = 'test_set_statistics'::regclass
+  AND attname = 't';
+ attname | attstattarget 
+---------+---------------
+ t       |              
+(1 row)
+
+-- Test AT_SetLogged / AT_SetUnLogged
+CREATE UNLOGGED TABLE test_logged_changes (
+	i int PRIMARY KEY,
+	t text
+) USING orioledb;
+-- Check initial unlogged state
+SELECT relname, relpersistence
+FROM pg_class
+WHERE relname = 'test_logged_changes';
+       relname       | relpersistence 
+---------------------+----------------
+ test_logged_changes | u
+(1 row)
+
+-- Change to logged
+ALTER TABLE test_logged_changes SET LOGGED;
+SELECT relname, relpersistence
+FROM pg_class
+WHERE relname = 'test_logged_changes';
+       relname       | relpersistence 
+---------------------+----------------
+ test_logged_changes | p
+(1 row)
+
+-- Change back to unlogged
+ALTER TABLE test_logged_changes SET UNLOGGED;
+SELECT relname, relpersistence
+FROM pg_class
+WHERE relname = 'test_logged_changes';
+       relname       | relpersistence 
+---------------------+----------------
+ test_logged_changes | u
+(1 row)
+
+-- Test with data
+INSERT INTO test_logged_changes VALUES (1, 'test data');
+ALTER TABLE test_logged_changes SET LOGGED;
+SELECT * FROM test_logged_changes;
+ i |     t     
+---+-----------
+ 1 | test data
+(1 row)
+
+-- Test AT_SetOptions / AT_ResetOptions (column-level options)
+CREATE TABLE test_column_options (
+	i int PRIMARY KEY,
+	t text
+) USING orioledb;
+-- Set column-level storage options
+ALTER TABLE test_column_options ALTER COLUMN t SET (n_distinct = 100, n_distinct_inherited = 50);
+-- Verify options are set
+SELECT attname, attoptions
+FROM pg_attribute
+WHERE attrelid = 'test_column_options'::regclass
+  AND attnum > 0
+  AND attoptions IS NOT NULL;
+ attname |                attoptions                
+---------+------------------------------------------
+ t       | {n_distinct=100,n_distinct_inherited=50}
+(1 row)
+
+-- Reset specific option
+ALTER TABLE test_column_options ALTER COLUMN t RESET (n_distinct);
+-- Verify reset
+SELECT attname, attoptions
+FROM pg_attribute
+WHERE attrelid = 'test_column_options'::regclass
+  AND attname = 't';
+ attname |        attoptions         
+---------+---------------------------
+ t       | {n_distinct_inherited=50}
+(1 row)
+
+-- Reset all options
+ALTER TABLE test_column_options ALTER COLUMN t RESET (n_distinct_inherited);
+SELECT attname, attoptions
+FROM pg_attribute
+WHERE attrelid = 'test_column_options'::regclass
+  AND attname = 't';
+ attname | attoptions 
+---------+------------
+ t       | 
+(1 row)
+
+-- Test AT_ResetRelOptions / AT_SetRelOptions (table-level options)
+CREATE TABLE test_table_options (
+	i int PRIMARY KEY,
+	t text
+) USING orioledb;
+-- Set table-level options
+ALTER TABLE test_table_options SET (fillfactor = 70, autovacuum_enabled = false);
+-- Verify table options
+SELECT relname, reloptions
+FROM pg_class
+WHERE relname = 'test_table_options';
+      relname       |                reloptions                
+--------------------+------------------------------------------
+ test_table_options | {fillfactor=70,autovacuum_enabled=false}
+(1 row)
+
+-- Reset specific option
+ALTER TABLE test_table_options RESET (autovacuum_enabled);
+SELECT relname, reloptions
+FROM pg_class
+WHERE relname = 'test_table_options';
+      relname       |   reloptions    
+--------------------+-----------------
+ test_table_options | {fillfactor=70}
+(1 row)
+
+-- Reset all options
+ALTER TABLE test_table_options RESET (fillfactor);
+SELECT relname, reloptions
+FROM pg_class
+WHERE relname = 'test_table_options';
+      relname       | reloptions 
+--------------------+------------
+ test_table_options | 
+(1 row)
+
+-- Test AT_ClusterOn / AT_DropCluster
+CREATE TABLE test_cluster (
+	i int,
+	t text,
+	v varchar,
+	PRIMARY KEY (i)
+) USING orioledb;
+CREATE INDEX test_cluster_idx ON test_cluster(t);
+-- Set cluster index
+ALTER TABLE test_cluster CLUSTER ON test_cluster_idx;
+WARNING:  alter table subcommand "CLUSTER ON" has no performance effect on OrioleDB tables with primary key
+-- Verify cluster setting
+SELECT indexrelid::regclass AS index_name, indisclustered
+FROM pg_index
+WHERE indrelid = 'test_cluster'::regclass
+ORDER BY indexrelid::regclass::text;
+    index_name     | indisclustered 
+-------------------+----------------
+ test_cluster_idx  | t
+ test_cluster_pkey | f
+(2 rows)
+
+-- Drop cluster setting
+ALTER TABLE test_cluster SET WITHOUT CLUSTER;
+WARNING:  alter table subcommand "SET WITHOUT CLUSTER" has no performance effect on OrioleDB tables with primary key
+-- Verify cluster removed
+SELECT indexrelid::regclass AS index_name, indisclustered
+FROM pg_index
+WHERE indrelid = 'test_cluster'::regclass
+ORDER BY indexrelid::regclass::text;
+    index_name     | indisclustered 
+-------------------+----------------
+ test_cluster_idx  | f
+ test_cluster_pkey | f
+(2 rows)
+
+-- Test AT_EnableRule / AT_DisableRule (on tables)
+-- ENABLE/DISABLE RULE commands only work on tables, not views
+CREATE TABLE test_rule_table (
+	i int PRIMARY KEY,
+	t text
+) USING orioledb;
+-- Create a rule on the table that filters certain inserts
+CREATE RULE test_insert_rule AS
+	ON INSERT TO test_rule_table
+	WHERE t = 'skip'
+	DO INSTEAD NOTHING;
+-- Verify rule is enabled (ev_enabled = 'O' means origin)
+SELECT rulename, ev_enabled
+FROM pg_rewrite
+WHERE rulename = 'test_insert_rule';
+     rulename     | ev_enabled 
+------------------+------------
+ test_insert_rule | O
+(1 row)
+
+-- Test that rule works: insert with 'skip' should be ignored
+INSERT INTO test_rule_table VALUES (1, 'skip');
+INSERT INTO test_rule_table VALUES (2, 'normal');
+SELECT * FROM test_rule_table ORDER BY i;
+ i |   t    
+---+--------
+ 2 | normal
+(1 row)
+
+-- Disable the rule
+ALTER TABLE test_rule_table DISABLE RULE test_insert_rule;
+-- Verify rule is disabled (ev_enabled = 'D')
+SELECT rulename, ev_enabled
+FROM pg_rewrite
+WHERE rulename = 'test_insert_rule';
+     rulename     | ev_enabled 
+------------------+------------
+ test_insert_rule | D
+(1 row)
+
+-- Now the 'skip' insert should work since rule is disabled
+INSERT INTO test_rule_table VALUES (1, 'skip');
+SELECT * FROM test_rule_table ORDER BY i;
+ i |   t    
+---+--------
+ 1 | skip
+ 2 | normal
+(2 rows)
+
+-- Enable the rule back (origin mode)
+ALTER TABLE test_rule_table ENABLE RULE test_insert_rule;
+SELECT rulename, ev_enabled
+FROM pg_rewrite
+WHERE rulename = 'test_insert_rule';
+     rulename     | ev_enabled 
+------------------+------------
+ test_insert_rule | O
+(1 row)
+
+-- Enable rule for replica (ev_enabled = 'R')
+ALTER TABLE test_rule_table ENABLE REPLICA RULE test_insert_rule;
+SELECT rulename, ev_enabled
+FROM pg_rewrite
+WHERE rulename = 'test_insert_rule';
+     rulename     | ev_enabled 
+------------------+------------
+ test_insert_rule | R
+(1 row)
+
+-- Enable rule always (ev_enabled = 'A')
+ALTER TABLE test_rule_table ENABLE ALWAYS RULE test_insert_rule;
+SELECT rulename, ev_enabled
+FROM pg_rewrite
+WHERE rulename = 'test_insert_rule';
+     rulename     | ev_enabled 
+------------------+------------
+ test_insert_rule | A
+(1 row)
+
+-- Cleanup
+DROP TABLE test_rule_table CASCADE;
+-- Test AT_CheckNotNull (internally generated for partitioned tables)
+-- AT_CheckNotNull is generated when you use ALTER TABLE ONLY ... SET NOT NULL
+-- on a partitioned table. It checks that child partitions already have NOT NULL.
+-- Create a partitioned table
+CREATE TABLE test_check_not_null (
+	i int,
+	val text NOT NULL
+) PARTITION BY RANGE (i) USING orioledb;
+-- Create partitions with NOT NULL already set
+CREATE TABLE test_check_not_null_p1 PARTITION OF test_check_not_null
+	FOR VALUES FROM (1) TO (100) USING orioledb;
+CREATE TABLE test_check_not_null_p2 PARTITION OF test_check_not_null
+	FOR VALUES FROM (100) TO (200) USING orioledb;
+-- Insert test data
+INSERT INTO test_check_not_null VALUES (1, 'abc'), (50, 'def'), (150, 'ghi');
+-- Verify partitions exist
+SELECT tablename FROM pg_tables
+WHERE schemaname = 'ddl' AND tablename LIKE 'test_check_not_null%'
+ORDER BY tablename;
+       tablename        
+------------------------
+ test_check_not_null
+ test_check_not_null_p1
+ test_check_not_null_p2
+(3 rows)
+
+-- Verify val column is already NOT NULL in all partitions
+SELECT c.relname, a.attname, a.attnotnull
+FROM pg_class c
+JOIN pg_attribute a ON a.attrelid = c.oid
+WHERE c.relname LIKE 'test_check_not_null%'
+  AND a.attname = 'val'
+  AND c.relnamespace = 'ddl'::regnamespace
+ORDER BY c.relname;
+        relname         | attname | attnotnull 
+------------------------+---------+------------
+ test_check_not_null    | val     | t
+ test_check_not_null_p1 | val     | t
+ test_check_not_null_p2 | val     | t
+(3 rows)
+
+-- Now use ALTER TABLE ONLY ... SET NOT NULL on parent
+-- This internally generates AT_CheckNotNull for each partition
+-- to verify they already have NOT NULL (which they do)
+ALTER TABLE ONLY test_check_not_null ALTER COLUMN val SET NOT NULL;
+-- Verify the operation succeeded
+SELECT c.relname, a.attname, a.attnotnull
+FROM pg_class c
+JOIN pg_attribute a ON a.attrelid = c.oid
+WHERE c.relname = 'test_check_not_null'
+  AND a.attname = 'val'
+  AND c.relnamespace = 'ddl'::regnamespace;
+       relname       | attname | attnotnull 
+---------------------+---------+------------
+ test_check_not_null | val     | t
+(1 row)
+
+-- Test that NOT NULL is enforced
+INSERT INTO test_check_not_null VALUES (75, NULL);
+ERROR:  null value in column "val" of relation "test_check_not_null_p1" violates not-null constraint
+DETAIL:  Failing row contains (75, null).
+-- Verify data is still correct
+SELECT * FROM test_check_not_null ORDER BY i;
+  i  | val 
+-----+-----
+   1 | abc
+  50 | def
+ 150 | ghi
+(3 rows)
+
+-- Test AT_CheckNotNull failure case: partition without NOT NULL
+CREATE TABLE test_check_not_null_fail (
+	i int,
+	val text  -- Note: no NOT NULL here!
+) PARTITION BY RANGE (i) USING orioledb;
+CREATE TABLE test_check_not_null_fail_p1 PARTITION OF test_check_not_null_fail
+	FOR VALUES FROM (1) TO (100) USING orioledb;
+-- Try to set NOT NULL on parent ONLY (should fail because partition doesn't have NOT NULL)
+ALTER TABLE ONLY test_check_not_null_fail ALTER COLUMN val SET NOT NULL;
+ERROR:  constraint must be added to child tables too
+DETAIL:  Column "val" of relation "test_check_not_null_fail_p1" is not already NOT NULL.
+HINT:  Do not specify the ONLY keyword.
+-- Test AT_ValidateConstraint (validate a NOT VALID constraint)
+CREATE TABLE test_validate_constraint (
+	i int PRIMARY KEY,
+	t text
+) USING orioledb;
+-- Insert some data
+INSERT INTO test_validate_constraint VALUES (1, 'test'), (2, 'data');
+-- Add a check constraint without validation
+ALTER TABLE test_validate_constraint ADD CONSTRAINT check_t_length CHECK (length(t) > 2) NOT VALID;
+-- Verify constraint exists but not validated
+SELECT conname, convalidated
+FROM pg_constraint
+WHERE conrelid = 'test_validate_constraint'::regclass
+  AND conname = 'check_t_length';
+    conname     | convalidated 
+----------------+--------------
+ check_t_length | f
+(1 row)
+
+-- Now validate the constraint
+ALTER TABLE test_validate_constraint VALIDATE CONSTRAINT check_t_length;
+-- Verify constraint is now validated
+SELECT conname, convalidated
+FROM pg_constraint
+WHERE conrelid = 'test_validate_constraint'::regclass
+  AND conname = 'check_t_length';
+    conname     | convalidated 
+----------------+--------------
+ check_t_length | t
+(1 row)
+
+-- Test AT_SetTableSpace (change tablespace)
+-- Note: This test assumes default tablespace exists
+CREATE TABLE test_tablespace (
+	i int PRIMARY KEY,
+	t text
+) USING orioledb;
+-- Try to set tablespace (may be no-op if no custom tablespace)
+-- This tests that the subcommand doesn't error out
+ALTER TABLE test_tablespace SET TABLESPACE pg_default;
+-- Test AT_GenericOptions (for foreign tables, but we test the subcommand handling)
+-- This is mainly to ensure the subcommand is accepted for OrioleDB tables
+-- even though it may not do anything meaningful
+-- Test constraint operations with existing ddl test patterns
+CREATE TABLE test_constraint_ops (
+	i int PRIMARY KEY,
+	val int,
+	CHECK (val > 0)
+) USING orioledb;
+INSERT INTO test_constraint_ops VALUES (1, 10), (2, 20);
+-- Verify data
+SELECT * FROM test_constraint_ops ORDER BY i;
+ i | val 
+---+-----
+ 1 |  10
+ 2 |  20
+(2 rows)
+
+-- Test dropping constraint
+ALTER TABLE test_constraint_ops DROP CONSTRAINT test_constraint_ops_val_check;
+-- Now we can insert negative values
+INSERT INTO test_constraint_ops VALUES (3, -5);
+SELECT * FROM test_constraint_ops ORDER BY i;
+ i | val 
+---+-----
+ 1 |  10
+ 2 |  20
+ 3 |  -5
+(3 rows)
+
+-- Test ReAdd* subcommands (triggered during table rewrites)
+-- These subcommands are used internally when ALTER TABLE causes a table rewrite
+-- Test AT_ReAddConstraint (triggered by ALTER TYPE with constraints)
+CREATE TABLE test_readd_constraint (
+	i int PRIMARY KEY,
+	val int CHECK (val > 0)
+) USING orioledb;
+INSERT INTO test_readd_constraint VALUES (1, 100), (2, 200);
+-- Verify constraint exists
+SELECT conname, contype
+FROM pg_constraint
+WHERE conrelid = 'test_readd_constraint'::regclass
+  AND contype = 'c'
+ORDER BY conname;
+             conname             | contype 
+---------------------------------+---------
+ test_readd_constraint_val_check | c
+(1 row)
+
+-- Change column type - this causes table rewrite and ReAddConstraint
+ALTER TABLE test_readd_constraint ALTER COLUMN val TYPE bigint;
+-- Verify constraint still exists after rewrite
+SELECT conname, contype
+FROM pg_constraint
+WHERE conrelid = 'test_readd_constraint'::regclass
+  AND contype = 'c'
+ORDER BY conname;
+             conname             | contype 
+---------------------------------+---------
+ test_readd_constraint_val_check | c
+(1 row)
+
+-- Verify constraint still works
+INSERT INTO test_readd_constraint VALUES (3, -5);
+ERROR:  new row for relation "test_readd_constraint" violates check constraint "test_readd_constraint_val_check"
+DETAIL:  Failing row contains (3, -5).
+SELECT * FROM test_readd_constraint ORDER BY i;
+ i | val 
+---+-----
+ 1 | 100
+ 2 | 200
+(2 rows)
+
+-- Test AT_ReAddIndex (triggered by ALTER TYPE on indexed columns)
+CREATE TABLE test_readd_index (
+	i int PRIMARY KEY,
+	code int,
+	name text
+) USING orioledb;
+CREATE INDEX test_readd_index_code_idx ON test_readd_index(code);
+CREATE INDEX test_readd_index_name_idx ON test_readd_index(name);
+INSERT INTO test_readd_index VALUES (1, 100, 'alice'), (2, 200, 'bob');
+-- Verify indexes exist
+SELECT indexname
+FROM pg_indexes
+WHERE tablename = 'test_readd_index'
+  AND schemaname = 'ddl'
+ORDER BY indexname;
+         indexname         
+---------------------------
+ test_readd_index_code_idx
+ test_readd_index_name_idx
+ test_readd_index_pkey
+(3 rows)
+
+-- Change non-indexed column type - causes table rewrite, indexes are preserved
+ALTER TABLE test_readd_index ALTER COLUMN name TYPE varchar(100);
+-- Verify indexes still exist after rewrite
+SELECT indexname
+FROM pg_indexes
+WHERE tablename = 'test_readd_index'
+  AND schemaname = 'ddl'
+ORDER BY indexname;
+         indexname         
+---------------------------
+ test_readd_index_code_idx
+ test_readd_index_name_idx
+ test_readd_index_pkey
+(3 rows)
+
+-- Verify indexes still work
+SET enable_seqscan = off;
+EXPLAIN (COSTS OFF) SELECT * FROM test_readd_index WHERE code = 100;
+                           QUERY PLAN                           
+----------------------------------------------------------------
+ Index Scan using test_readd_index_code_idx on test_readd_index
+   Index Cond: (code = 100)
+(2 rows)
+
+SELECT * FROM test_readd_index WHERE code = 100;
+ i | code | name  
+---+------+-------
+ 1 |  100 | alice
+(1 row)
+
+RESET enable_seqscan;
+-- Test AT_ReAddStatistics (triggered by table rewrite with statistics)
+CREATE TABLE test_readd_statistics (
+	i int PRIMARY KEY,
+	val int,
+	txt text
+) USING orioledb;
+-- Set custom statistics targets
+ALTER TABLE test_readd_statistics ALTER COLUMN val SET STATISTICS 500;
+ALTER TABLE test_readd_statistics ALTER COLUMN txt SET STATISTICS 1000;
+-- Verify statistics targets are set
+SELECT attname, attstattarget
+FROM pg_attribute
+WHERE attrelid = 'test_readd_statistics'::regclass
+  AND attnum > 0
+ORDER BY attnum;
+ attname | attstattarget 
+---------+---------------
+ i       |              
+ val     |           500
+ txt     |          1000
+(3 rows)
+
+-- Cause a table rewrite by changing a column type
+ALTER TABLE test_readd_statistics ALTER COLUMN i TYPE bigint;
+-- Verify statistics targets are preserved after rewrite
+SELECT attname, attstattarget
+FROM pg_attribute
+WHERE attrelid = 'test_readd_statistics'::regclass
+  AND attnum > 0
+ORDER BY attnum;
+ attname | attstattarget 
+---------+---------------
+ i       |              
+ val     |           500
+ txt     |          1000
+(3 rows)
+
+-- Test AT_ReAddComment (triggered by table rewrite with column comments)
+CREATE TABLE test_readd_comment (
+	i int PRIMARY KEY,
+	val int
+) USING orioledb;
+-- Add comments to columns
+COMMENT ON COLUMN test_readd_comment.i IS 'Primary key column';
+COMMENT ON COLUMN test_readd_comment.val IS 'Value column';
+-- Verify comments exist
+SELECT a.attname, d.description
+FROM pg_attribute a
+LEFT JOIN pg_description d ON d.objoid = a.attrelid AND d.objsubid = a.attnum
+WHERE a.attrelid = 'test_readd_comment'::regclass
+  AND a.attnum > 0
+ORDER BY a.attnum;
+ attname |    description     
+---------+--------------------
+ i       | Primary key column
+ val     | Value column
+(2 rows)
+
+-- Cause table rewrite
+ALTER TABLE test_readd_comment ALTER COLUMN val TYPE bigint;
+-- Verify comments are preserved after rewrite
+SELECT a.attname, d.description
+FROM pg_attribute a
+LEFT JOIN pg_description d ON d.objoid = a.attrelid AND d.objsubid = a.attnum
+WHERE a.attrelid = 'test_readd_comment'::regclass
+  AND a.attnum > 0
+ORDER BY a.attnum;
+ attname |    description     
+---------+--------------------
+ i       | Primary key column
+ val     | Value column
+(2 rows)
+
+-- Test AT_ReplaceRelOptions (used by CREATE OR REPLACE VIEW with options)
+-- AT_ReplaceRelOptions is triggered internally when CREATE OR REPLACE VIEW
+-- changes the view's options (security_barrier, security_invoker, check_option)
+CREATE TABLE test_view_base (
+	i int PRIMARY KEY,
+	t text,
+	val int
+) USING orioledb;
+INSERT INTO test_view_base VALUES (1, 'alice', 100), (2, 'bob', 200), (3, 'charlie', 300);
+-- Create view without options
+CREATE VIEW test_replace_view AS SELECT * FROM test_view_base WHERE val > 0;
+-- Check initial view options (should be NULL or empty)
+SELECT relname, relkind, reloptions
+FROM pg_class
+WHERE relname = 'test_replace_view';
+      relname      | relkind | reloptions 
+-------------------+---------+------------
+ test_replace_view | v       | 
+(1 row)
+
+-- Use CREATE OR REPLACE VIEW to add security_barrier option
+-- This triggers AT_ReplaceRelOptions internally
+CREATE OR REPLACE VIEW test_replace_view WITH (security_barrier=true)
+AS SELECT * FROM test_view_base WHERE val > 100;
+-- Verify security_barrier option is set
+SELECT relname, relkind, reloptions
+FROM pg_class
+WHERE relname = 'test_replace_view';
+      relname      | relkind |       reloptions        
+-------------------+---------+-------------------------
+ test_replace_view | v       | {security_barrier=true}
+(1 row)
+
+-- Test the view still works
+SELECT * FROM test_replace_view ORDER BY i;
+ i |    t    | val 
+---+---------+-----
+ 2 | bob     | 200
+ 3 | charlie | 300
+(2 rows)
+
+-- Replace view again with different options (security_invoker)
+-- This replaces the entire options list with new one
+CREATE OR REPLACE VIEW test_replace_view WITH (security_invoker=true)
+AS SELECT * FROM test_view_base WHERE val > 50;
+-- Verify options replaced (should now have security_invoker, not security_barrier)
+SELECT relname, relkind, reloptions
+FROM pg_class
+WHERE relname = 'test_replace_view';
+      relname      | relkind |       reloptions        
+-------------------+---------+-------------------------
+ test_replace_view | v       | {security_invoker=true}
+(1 row)
+
+SELECT * FROM test_replace_view ORDER BY i;
+ i |    t    | val 
+---+---------+-----
+ 1 | alice   | 100
+ 2 | bob     | 200
+ 3 | charlie | 300
+(3 rows)
+
+-- Replace view with multiple options
+CREATE OR REPLACE VIEW test_replace_view
+WITH (security_barrier=true, security_invoker=true, check_option=local)
+AS SELECT * FROM test_view_base WHERE val > 0;
+-- Verify multiple options set
+SELECT relname, relkind, reloptions
+FROM pg_class
+WHERE relname = 'test_replace_view';
+      relname      | relkind |                            reloptions                            
+-------------------+---------+------------------------------------------------------------------
+ test_replace_view | v       | {security_barrier=true,security_invoker=true,check_option=local}
+(1 row)
+
+-- Replace view with no options (clears all options)
+CREATE OR REPLACE VIEW test_replace_view
+AS SELECT * FROM test_view_base WHERE val >= 100;
+-- Verify options cleared
+SELECT relname, relkind, reloptions
+FROM pg_class
+WHERE relname = 'test_replace_view';
+      relname      | relkind | reloptions 
+-------------------+---------+------------
+ test_replace_view | v       | 
+(1 row)
+
+SELECT * FROM test_replace_view ORDER BY i;
+ i |    t    | val 
+---+---------+-----
+ 1 | alice   | 100
+ 2 | bob     | 200
+ 3 | charlie | 300
+(3 rows)
+
+DROP VIEW test_replace_view;
+DROP TABLE test_view_base CASCADE;
+-- Test AT_ReAddDomainConstraint (domain constraints during table rewrite)
+-- Domain constraints need to be re-verified when table is rewritten
+-- Create a domain with CHECK constraint
+CREATE DOMAIN positive_int AS int CHECK (VALUE > 0);
+CREATE DOMAIN email_type AS varchar(100) CHECK (VALUE ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');
+CREATE TABLE test_readd_domain_constraint (
+	i int PRIMARY KEY,
+	quantity positive_int,
+	contact_email email_type
+) USING orioledb;
+-- Insert valid data
+INSERT INTO test_readd_domain_constraint VALUES (1, 100, 'user@example.com');
+INSERT INTO test_readd_domain_constraint VALUES (2, 50, 'admin@test.org');
+-- Verify domain constraints work before rewrite
+INSERT INTO test_readd_domain_constraint VALUES (3, -5, 'valid@email.com');  -- Should fail: negative quantity
+ERROR:  value for domain positive_int violates check constraint "positive_int_check"
+INSERT INTO test_readd_domain_constraint VALUES (4, 10, 'invalid-email');    -- Should fail: invalid email format
+ERROR:  value for domain email_type violates check constraint "email_type_check"
+SELECT * FROM test_readd_domain_constraint ORDER BY i;
+ i | quantity |  contact_email   
+---+----------+------------------
+ 1 |      100 | user@example.com
+ 2 |       50 | admin@test.org
+(2 rows)
+
+-- Verify domain constraints exist in catalog
+SELECT t.typname, c.conname, c.consrc
+FROM pg_constraint c
+JOIN pg_type t ON t.oid = c.contypid
+WHERE t.typname IN ('positive_int', 'email_type')
+ORDER BY t.typname, c.conname;
+ERROR:  column c.consrc does not exist
+LINE 1: SELECT t.typname, c.conname, c.consrc
+                                     ^
+HINT:  Perhaps you meant to reference the column "c.conkey" or the column "c.conbin".
+-- Cause table rewrite by changing a different column
+-- This should trigger AT_ReAddDomainConstraint for the domain columns
+ALTER TABLE test_readd_domain_constraint ADD COLUMN extra_data text;
+ALTER TABLE test_readd_domain_constraint ALTER COLUMN extra_data TYPE varchar(50);
+-- Verify domain constraints still work after rewrite
+INSERT INTO test_readd_domain_constraint (i, quantity, contact_email) VALUES (5, -10, 'test@example.com');  -- Should fail
+ERROR:  value for domain positive_int violates check constraint "positive_int_check"
+INSERT INTO test_readd_domain_constraint (i, quantity, contact_email) VALUES (6, 20, 'bad-email');          -- Should fail
+ERROR:  value for domain email_type violates check constraint "email_type_check"
+INSERT INTO test_readd_domain_constraint (i, quantity, contact_email) VALUES (7, 75, 'good@email.com');     -- Should succeed
+SELECT * FROM test_readd_domain_constraint ORDER BY i;
+ i | quantity |  contact_email   | extra_data 
+---+----------+------------------+------------
+ 1 |      100 | user@example.com | 
+ 2 |       50 | admin@test.org   | 
+ 7 |       75 | good@email.com   | 
+(3 rows)
+
+-- Verify domain constraints still exist after rewrite
+SELECT t.typname, c.conname, c.consrc
+FROM pg_constraint c
+JOIN pg_type t ON t.oid = c.contypid
+WHERE t.typname IN ('positive_int', 'email_type')
+ORDER BY t.typname, c.conname;
+ERROR:  column c.consrc does not exist
+LINE 1: SELECT t.typname, c.conname, c.consrc
+                                     ^
+HINT:  Perhaps you meant to reference the column "c.conkey" or the column "c.conbin".
+-- Test with domain that has NOT NULL constraint
+CREATE DOMAIN nonempty_text AS text NOT NULL CHECK (length(VALUE) > 0);
+CREATE TABLE test_domain_not_null (
+	i int PRIMARY KEY,
+	description nonempty_text
+) USING orioledb;
+INSERT INTO test_domain_not_null VALUES (1, 'Valid description');
+INSERT INTO test_domain_not_null VALUES (2, NULL);  -- Should fail: NOT NULL
+ERROR:  domain nonempty_text does not allow null values
+INSERT INTO test_domain_not_null VALUES (3, '');    -- Should fail: length check
+ERROR:  value for domain nonempty_text violates check constraint "nonempty_text_check"
+SELECT * FROM test_domain_not_null ORDER BY i;
+ i |    description    
+---+-------------------
+ 1 | Valid description
+(1 row)
+
+-- Cause rewrite
+ALTER TABLE test_domain_not_null ALTER COLUMN i TYPE bigint;
+-- Verify constraints still enforced after rewrite
+INSERT INTO test_domain_not_null VALUES (4, NULL);  -- Should fail
+ERROR:  domain nonempty_text does not allow null values
+INSERT INTO test_domain_not_null VALUES (5, '');    -- Should fail
+ERROR:  value for domain nonempty_text violates check constraint "nonempty_text_check"
+INSERT INTO test_domain_not_null VALUES (6, 'Another valid description');  -- Should succeed
+SELECT * FROM test_domain_not_null ORDER BY i;
+ i |        description        
+---+---------------------------
+ 1 | Valid description
+ 6 | Another valid description
+(2 rows)
+
+-- Cleanup domains
+DROP TABLE test_domain_not_null CASCADE;
+DROP TABLE test_readd_domain_constraint CASCADE;
+DROP DOMAIN nonempty_text;
+DROP DOMAIN email_type;
+DROP DOMAIN positive_int;
+-- Test AT_SetCompression (column compression method)
+-- PostgreSQL supports compression methods: pglz (default), lz4
+CREATE TABLE test_set_compression (
+	i int PRIMARY KEY,
+	data1 text
+) USING orioledb;
+-- Check initial compression settings (should be DEFAULT or empty)
+SELECT attname, attcompression
+FROM pg_attribute
+WHERE attrelid = 'test_set_compression'::regclass
+  AND attname = 'data1'
+ORDER BY attname;
+ attname | attcompression 
+---------+----------------
+ data1   | 
+(1 row)
+
+-- Set compression method for data1 column
+ALTER TABLE test_set_compression ALTER COLUMN data1 SET COMPRESSION pglz;
+ERROR:  unsupported alter table subcommand
+DETAIL:  Subcommand "ALTER COLUMN ... SET COMPRESSION" is not supported on OrioleDB tables yet.  This will be implemented in future.
+DROP TABLE test_set_compression CASCADE;
+-- Test AT_SetExpression (ALTER TABLE ... ALTER COLUMN ... SET EXPRESSION)
+-- AT_SetExpression allows changing the generation expression for a STORED generated column
+-- This feature is available in PostgreSQL 17+
+CREATE TABLE test_set_expression (
+	i int PRIMARY KEY,
+	price numeric(10,2),
+	quantity int,
+	total numeric(10,2) GENERATED ALWAYS AS (price * quantity) STORED
+) USING orioledb;
+-- Insert test data
+INSERT INTO test_set_expression (i, price, quantity) VALUES (1, 10.50, 5);
+INSERT INTO test_set_expression (i, price, quantity) VALUES (2, 25.00, 3);
+INSERT INTO test_set_expression (i, price, quantity) VALUES (3, 7.99, 10);
+-- Verify initial generated column values (price * quantity)
+SELECT i, price, quantity, total FROM test_set_expression ORDER BY i;
+ i | price | quantity | total 
+---+-------+----------+-------
+ 1 | 10.50 |        5 | 52.50
+ 2 | 25.00 |        3 | 75.00
+ 3 |  7.99 |       10 | 79.90
+(3 rows)
+
+-- Check the initial generated column expression in catalog
+SELECT a.attname, a.attgenerated, pg_get_expr(d.adbin, d.adrelid) as generation_expr
+FROM pg_attribute a
+JOIN pg_attrdef d ON d.adrelid = a.attrelid AND d.adnum = a.attnum
+WHERE a.attrelid = 'test_set_expression'::regclass
+  AND a.attname = 'total';
+ attname | attgenerated |        generation_expr        
+---------+--------------+-------------------------------
+ total   | s            | (price * (quantity)::numeric)
+(1 row)
+
+-- Use AT_SetExpression to change the generation formula
+-- Change from (price * quantity) to (price * quantity * 1.1) to add 10% markup
+ALTER TABLE test_set_expression
+  ALTER COLUMN total SET EXPRESSION AS (price * quantity * 1.1);
+-- Verify the expression was updated in catalog
+SELECT a.attname, a.attgenerated, pg_get_expr(d.adbin, d.adrelid) as generation_expr
+FROM pg_attribute a
+JOIN pg_attrdef d ON d.adrelid = a.attrelid AND d.adnum = a.attnum
+WHERE a.attrelid = 'test_set_expression'::regclass
+  AND a.attname = 'total';
+ attname | attgenerated |            generation_expr            
+---------+--------------+---------------------------------------
+ total   | s            | ((price * (quantity)::numeric) * 1.1)
+(1 row)
+
+-- Verify all existing values were recalculated with new expression
+SELECT i, price, quantity, total,
+	(price * quantity * 1.1) as expected_total
+FROM test_set_expression
+ORDER BY i;
+ i | price | quantity | total | expected_total 
+---+-------+----------+-------+----------------
+ 1 | 10.50 |        5 | 52.50 |         57.750
+ 2 | 25.00 |        3 | 75.00 |         82.500
+ 3 |  7.99 |       10 | 79.90 |         87.890
+(3 rows)
+
+UPDATE test_set_expression SET price = 15.00 WHERE i = 1;
+-- Verify recalculation after update
+SELECT i, price, quantity, total,
+	(price * quantity * 1.1) as expected_total
+FROM test_set_expression
+ORDER BY i;
+ i | price | quantity | total | expected_total 
+---+-------+----------+-------+----------------
+ 1 | 15.00 |        5 | 82.50 |         82.500
+ 2 | 25.00 |        3 | 75.00 |         82.500
+ 3 |  7.99 |       10 | 79.90 |         87.890
+(3 rows)
+
+-- Insert new row to verify new expression is used for new data
+INSERT INTO test_set_expression (i, price, quantity) VALUES (4, 20.00, 2);
+SELECT i, price, quantity, total,
+	(price * quantity * 1.1) as expected_total
+FROM test_set_expression
+ORDER BY i;
+ i | price | quantity | total | expected_total 
+---+-------+----------+-------+----------------
+ 1 | 15.00 |        5 | 82.50 |         82.500
+ 2 | 25.00 |        3 | 75.00 |         82.500
+ 3 |  7.99 |       10 | 79.90 |         87.890
+ 4 | 20.00 |        2 | 44.00 |         44.000
+(4 rows)
+
+DROP TABLE test_set_expression CASCADE;
 DROP EXTENSION orioledb CASCADE;
 NOTICE:  drop cascades to 39 other objects
 DETAIL:  drop cascades to table o_ddl_missing
@@ -1546,6 +2446,20 @@
 drop cascades to table test_replica_identity_set
 drop cascades to table test_replica_identity_fail
 drop cascades to table test_set_access_method_fail
+drop cascades to table test_set_statistics
+drop cascades to table test_logged_changes
+drop cascades to table test_column_options
+drop cascades to table test_table_options
+drop cascades to table test_cluster
+drop cascades to table test_check_not_null
+drop cascades to table test_check_not_null_fail
+drop cascades to table test_validate_constraint
+drop cascades to table test_tablespace
+drop cascades to table test_constraint_ops
+drop cascades to table test_readd_constraint
+drop cascades to table test_readd_index
+drop cascades to table test_readd_statistics
+drop cascades to table test_readd_comment
 DROP SCHEMA ddl CASCADE;
 NOTICE:  drop cascades to 5 other objects
 DETAIL:  drop cascades to function pseudo_random(bigint,bigint)
